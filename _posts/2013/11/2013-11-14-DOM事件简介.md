---
layout: post
title: How DOM Events Work [译]
categories:
- programming
tag:
- JavaScript
---

这篇文章虽说是简介，但是讲的方面非常多，是 Smashing Magazine 上新鲜出炉的一篇好文，所以决定翻译一下，也当作一个学习。  
原文链接：[An Introduction to DOM Events](http://coding.smashingmagazine.com/2013/11/12/an-introduction-to-dom-events/)

## 引子
DOM事件一说，肯定是一大堆的，比如：`click, touch, load, drag, change, input, error, resize` 等等。事件通常来讲有如下几个特性：

- 事件是可以在文档的任何一个位置被触发的，不管是通过用户交互还是通过浏览器自动触发
- 事件不是说在一个地方被触发就在那里结束，它通常会在文档中上串下跳，直到它的生命结束
- 事件的生命周期，正是事件本身的奥妙所在，也是我们能够理解事件是如何工作的精髓所在

接下来，本文主要要介绍的，就是告诉你，DOM事件是如何工作的。

## 监听事件
在过去，浏览器对于如何在DOM节点上设置监听器的实现方式不一而足。而jQuery库也正因为它做到了把这些不同剔除，提供了一个统一的事件监听机制而变得弥足珍贵（*这句话我就不吐槽了，因为jQuery对IE 6也是束手无策的*）。  
随着浏览器环境越来越标准化，我们就可以使用官方文档提供的API时也会显得更安全一些（可以兼容更多浏览器）。这篇文章里，主要描述在现代浏览器中如何操作事件。对于IE8及其以下的，可以找 `polyfill` 或者 `jQuery` 救火。  
在Js中，设置事件监听的API如下：

    // API, 3 params
    element.addEventListener(<event-name>, <callback>, <use-capture>);

    // example
    var element = document.getElementById('element');

    function callback() {
        alert('hola!');
        }

    element.addEventListener('click', callback);

如上所示，是很简单的一个监听器的设置。

## 移除监听
一般人只设置，不移除，而在最佳实践中，移除是有好处的，其API如下：

    // API, 3 params, at least first 2 params should be provided
    element.removeEventListener(<event-name>, <callback>, <use-capture>);
    
    // example
    var element = document.getElementById('element');

    function callback() {
        alert('Hello once');
        element.removeEventListener('click', callback);
    }

    element.addEventListener('click', callback);
    
## 维护**正确的**回调函数上下文

### **错误的回调上下文**
首先来看一个错误的回调上下文的例子：

    var element = document.getElementById('element');
    
    var user = {
        firstname : 'Wilson', 
        greeting : function() {
            alert('My name is ' + this.firstname);
        }
    };
    
    element.addEventListener('click', user.greeting);
    
    // result: alert
    'My name is undefined'
    
上面这个例子，我们把 `user.greeting` 丢给 `addEventListener` 时，**我们仅仅丢了一个 `greeting` 函数的引用给它，但是 `user` 对象的上下文却没有随同 `greeting` 这个引用一起被丢过去。所以，在 `addEventListener` 内部，回调函数是在 `element` 的上下文中被执行，那么当跑到 `this.firstname` 的时候，这个 `this` 指向的就是 `element` 而不是 `user` 上下文了，所以抛出了 undefined 也就不奇怪了，懂了么，骚年？

### **包一层匿名函数解决问题**

    element.addEventListener('click', function() {
        user.greeting();   // alert 'My name is Wilson'
    });
    
在包了一层匿名函数之后，这时候 `user.greeting()` 是**有带括号的**，表示立即执行，它当然去读取的执行上下文就是 `user` 了，所以这个时候跑起来是正确的。

### **用bind解决**
这个方案比较不提倡，但是也是个方法就是了：

    // 重写 user 中的 greeting 方法
    user.greeting = user.greeting.bind(user);
    
    // 丢一个引用给监听器
    element.addEventListener('click', user.greeting);
    
    // 可以选择性移除
    element.removeEventListener('click', user.greeting);

## Event对象