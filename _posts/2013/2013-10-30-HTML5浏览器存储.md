---
layout: post
title: HTML5存储的过去，现在，未来 [译]
categories:
- Translation
tag:
- HTML5 Storage
---

原文链接：[HTML5 Browser Storage: the Past, Present and Future](http://www.sitepoint.com/html5-browser-storage-past-present-future/)

其实，之前已经翻过一篇关于HTML5存储的文章了，这一篇是更加深入一些的，个人觉的，下面，走你了。

## 目录

- [为啥要把数据存在Client?](#p1)
- [本地存储方案1：Js变量](#p2)
- [本地存储方案2：cookies](#p3)
- [本地存储方案3：window.name](#p4)
- [本地存储方案4：HTML5 Web SQL数据库](#p5)
- [本地存储方案5：HTML5 Web Storage](#p6)
- [本地存储方案6：HTML5 IndexedDB](#p7)
- [本地存储方案7：HTML5 File API](#p8)
- [总结](#p9)

## <a name="p1">为啥要把数据存在Client?</a>
主要原因是出于最佳实践方面的考虑。跑在浏览器客户端的Js代码不需要将所有的信息往server端发送，这就有了把数据存在client端的需求。有如下几种情况：

- **提高性能**：通过将data缓存（cache）在客户端，这样data可以在无需发起多余的server端请求的情况下被获取。
- 对于数量巨大的且只在客户端用的到的数据，比如，`HTML字符串` 或者 `组件配置设置信息`等。
- **离线应用**的情况

## <a name="p2">Js变量的过去，现在和未来</a>
最简单的一种实现本地存储的方法当属JavaScript变量了。你可以像如下代码一样，创建一个全局变量来保存你应用的相关数据。

	// global application storage
	var appDataStore = {};

	// set values
	appDataStore.hello = "Hello World!";
	appDataStore.info = { a:1, b:2, c:3 };

	// get values
	console.log(appDataStore.hello);
	console.log(appDataStore.info.b);

比上面稍微复杂点的是，你可以把数据作为页面DOM节点的 `attributes` 或者 `properties` 进行存储。这种方式对于那些 `与view组件相关的数据` 尤其有用。但是它相较于Js变量来说更慢，而且风险性更高。不同的浏览器或者别的库可能在解析这种数据时采用的是意想不到的策略，从而导致了难以预料的后果。

	// store data in node
	var mywidget = document.getElementById("mywidget");
	mywidget.setAttribute("data-myvalue", "Hello World!");

	// retrieve values
	mywidget.textContent = mywidget.getAttribute("data-myvalue");

通过对以上两种方式的描述，我们可以大致得到Js变量实现的本地存储的优缺点：

- 优点：
	+ 更快，更简单
	+ 无需将data序列化/解序列化
	+ 对于单页面应用非常理想

- 弱点：
	+ 非常脆弱：因为是全局的，在页面哪里都可以取到，但是一旦用户按 `F5` 或者关闭当前的网页Tab，就杯具了
	+ 全局变量很容易通过第三方脚本被改写

## <a name="p3">cookies的过去，现在和未来</a>
...

## <a name="p4">window.name的过去，现在和未来</a>
...

## <a name="p5">HTML5过去的存储方式：Web SQL DB</a>
...

## <a name="p6">HTML5现在和将来的存储方式之一：HTML5 Web Storage</a>
...

## <a name="p7">HTML5将来的存储方式之二：HTML5 IndexedDB</a>
...

## <a name="p8">HTML5将来的存储方式之三：HTML5 File API</a>
...

## <a name="p9">总结</a>
...